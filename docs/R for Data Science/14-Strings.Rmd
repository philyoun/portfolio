---
title: "14 Strings"
output: github_document
---

## 14.1 Introduction
이 chapter에서는, R에서 string 조작manipulation을 어떻게 해야할지 알려줄 것이다. <br />
어떻게 strings가 작동하는지를 배우고, 어떻게 손으로 만들어낼 수 있는지도 배우지만, <br />
이 chapter의 핵심은 regular expression, 줄여서 regexps라고 부르는 것이다.

Regexp는 유용하다. 왜냐하면, <br />
strings는 보통 구조가 없거나 좀 덜한(structured or semi-structured) 데이터를 가지고 있는데, <br />
&emsp;&emsp;&emsp;&emsp;regexp는 strings의 패턴을 묘사해주는, 간결한concise 언어이기 때문. <br />
처음 regexp를 볼 때면, 고양이가 키보드 위를 걸어간 것 같겠지만, 이해하고 나면 말이 될 것이다.

(이 글에서는, Regular expression = regexp = 정규표현식 3단어 모두 혼용해서 씁니당)


### 14.1.1 Prerequisites
이 chapter에서는 string 조작을 위해, stringr 패키지를 사용할 것이다. <br />
항상 텍스트 데이터를 다루는게 아니라서, stringr은 tidyverse의 핵심 부분이 아니기에, <br />
따로 explicit하게 로드를 해줘야한다. <br />
(라고 되어 있지만 `library(tidyverse)`하면 stringr 패키지도 로드된다.)

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(stringr)
```

___

## 14.2 String basics
작은 따옴표나 큰 따옴표 아무거나 써서 strings를 만들 수 있다. <br />
다른 언어와는 다르게, 이 둘은 아무런 차이가 없다. <br />
저자는 항상 `"`를 사용할 것을 추천한다. string이 여러 개의 `"`를 포함하고 있지 않는 이상. <br />

```{r}
string1 <- "This is a string"
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
```

만약 따옴표 닫는걸 깜빡했다면, `+`라는 continuation character를 보게 될 것이다.

```{r eval=FALSE}
> "This is a string without a closing quote
+
+
+ HELP I'M STUCK
```

이런 일이 일어나면, Esc 키를(Escape 키라고 부르나 봄) 누르면 된다.

string에다가 진짜로 작은 따옴표나 큰 따옴표를 넣고 싶다면, 앞에다가 `\`를 사용해서 "escape"해야 한다.

```{r}
double_quote <- "\"" # 아니면 '"'
single_quote <- '\'' # 아니면 "'"
```

이 말인즉슨, 만약에 진짜 백슬래쉬(`\`)를 넣고 싶다면, 얘도 escape해줘야 한다는 뜻. <br />
즉, `"\\"`

프린트된 문자열 표현printed representation of string이, 그 자체로 string이 아니라는 걸 주의하자. <br />
왜냐하면 프린트된 문자열 표현은 escapes를 보여주기 때문. <br />
string의 raw contents를 보고 싶다면, `writeLines()`를 사용해야한다.

```{r collapse=TRUE}
x <- c("\"", "\\")
x

writeLines(x)
```

특별한 캐릭터들이 좀 있다. <br />
가장 흔한 걸로는 `"\n"`는 newline, `"\t"`는 tab. <br />
완전한 리스트를 보고싶다면, `"`에 help를 해볼 것. `?'"'` 혹은 `?"'"` <br />
가끔 `"\u00b5"`와 같은 string도 볼 수 있는데, 모든 플랫폼에서 작동하는 non-English 캐릭터를 쓰는 방법이다.

```{r collapse=TRUE}
x <- "\u00b5"
x
```

여러 개의 strings를, `c()`를 이용해 character vector에 저장할 수 있다.

```{r collapse=TRUE}
c("one", "two", "three")
```


### 14.2.1 String Length
base R에는 strings를 작업할 수 있는 여러가지 함수들이 있다. <br />
근데 이것들은 일관적이지 않아서inconsistent 기억을 하기가 힘들다. <br />
그렇기 때문에 사용하지 않을거다. 

대신에 stringr에 있는 함수들을 쓸 것이다. <br />
이 함수들은 전부다 str_로 시작하기 때문에 직관적인 이름들을 가지고 있다. <br />
예를 들어, `str_length()`는 해당 string의 길이가 얼마나 되는지를 알려준다.

```{r collapse=TRUE}
str_length(c("a", "R for data science", NA))
```

RStudio에서 작업을 하면 더 편리하다. <br />
`str_`라고 치기만 하면 자동완성autocomplete이 되기 때문에, 다른 stringr 함수들을 볼 수가 있다. <br />
![그림1](https://d33wubrfki0l68.cloudfront.net/7d1defbecac1e73595c3841f2753a09734dcb0be/0b58f/screenshots/stringr-autocomplete.png){ width=50% }

### 14.2.2 Combining strings
2개 이상의 string들을 결합하고 싶다면, `str_c()`를 사용하자.
```{r collapse=TRUE}
str_c("x", "y")
str_c("x", "y", "z")
```

`sep` 인자argument를 사용해서 어떻게 분리를 할지 컨트롤할 수 있다.
```{r collapse=TRUE}
str_c("x", "y", sep = ", ")
```

R의 다른 대부분의 함수들과 마찬가지로, 결측값missing values는 위험할 수 있다. <br />
그냥 `"NA"` 그대로 프린트하고 싶다면, `str_replace_na()`을 사용하자.
```{r collapse=TRUE}
x <- c("abc", NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")
```

위에서 볼 수 있듯, `str_c()`는 벡터화vectorized되고, 길이가 안 맞는게 있다면 recycle을 해서 맞춘다.
```{r collapse=TRUE}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```

길이 0짜리 오브젝트들은 조용하게 드랍된다. Objects of length 0 are silently dropped. <br />
이건 `if` 문과 함께 쓸 때 특히나 유용하다.
```{r collapse=TRUE}
name <- "Hadley"
time_of_day <- "morning"
birthday <- FALSE

str_c(
	"Good ", time_of_day, " ", name, 
	if (birthday) " and HAPPY BIRTHDAY",
	"."
)
```


strings의 벡터를 하나로 축소collapse하고 싶다면, `collapse` 인자argument를 사용하자.
```{r collapse=TRUE}
str_c(c("x", "y", "z"), collapse = ", ")
```

### 14.2.3 Subsetting strings
`str_sub()`를 사용해서, string의 일부를 추출해낼 수 있다. <br />
string과 마찬가지로, `str_sub()`도 substring의 포지션을 알려주는, `start`와 `end` 인자들arguments을 받는다.
```{r collapse=TRUE}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)

str_sub(x, -3, -1)
```

`str_sub()`는 string이 너무 짧아도 상관없다는 걸 인지하시라. <br />
가능한만큼만 return한다.
```{r collapse=TRUE}
str_sub("a", 1, 5)
```

strings를 수정하기 위해서, `str_sub()`를 assignment form으로 써줄 수 있다. <br />
위의 "Apple", "Banana", "Pear"의 첫 글자를 소문자로 수정하고 싶다고 치자.
```{r collapse=TRUE}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x
```

이렇게도 수정을 할 수가 있다는 말.

### 14.2.4 Locales
위에서 텍스트를 소문자로 바꿀 때 `str_to_lower()`을 사용했다. <br />
마찬가지로 `str_to_upper()`와 `str_to_title()`도 있다. <br />
하지만, 이렇게 바꾸는건 생각보다 복잡하다. <br />
왜냐하면 각 언어마다 바꾸는게 좀 다른 룰을 가지고 있기 때문. <br />
그럴 때, locale을 정해줌으로써 룰을 정할 수 있다.

```{r collapse=TRUE}
# 터키는 2개의 i를 갖고 있다. 점이 있는 것과 없는 것. 그래서 대문자화하면 다르게 된다.
str_to_upper(c("i", "ı"))
str_to_upper(c("i", "ı"), locale = "tr")
```

locale은 ISO 639 언어코드로 정해져있다. 언어 코드는 2, 3개의 줄임말로 되어있다는거. <br />
tr, kr 등등..
어떤 언어의 코드를 모르겠다면, [Wikipedia](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)에 리스트가 나와 있다. <br />
locale 부분을 비워두면, operating system에 있는 current locale대로 사용한다.
(우리나라를 찾아보니 kr이 아니고 ko로 쓰네.)

locale에 영향을 받는 또다른 중요한 operation은 sorting이다. <br />
base R의 `order()`과 `sort()` 함수들은 현재 locale을 이용해서 strings를 정렬sort한다. <br />
다른 컴퓨터들간에도 변함없는 결과를 얻고 싶다면robust behavior, <br />
&emsp;&emsp;&emsp;&emsp;`str_sort()`와 `str_order()`을 사용해서 `locale` 인자argument를 컨트롤해라.

```{r collapse=TRUE}
x <- c("apple", "eggplant", "banana")

str_sort(x, locale = "en")

str_sort(x, locale = "haw")
```


### 14.2.5 Exercises
___

## 14.3 Matching patterns with regular expressions
Regexps(이하 정규표현식)는 string에 있는 패턴을 묘사할 수 있도록 해주는, 매우 간결한terse 언어다. 
처음엔 낯설지만, 이해하고 나면 매우 유용하다.

regular expressions(이하 정규표현식)를 배우기 위해서, str_view()와 str_view_all()를 사용할거다.
이 함수들은 character vector와 정규표현식을 받고, 어떻게 매치가 되는지를 보여줄거다.

매우 간단한 정규표현식에서 시작해서, 점점 더 복잡해져갈 것이다. 
이 패턴 매칭을 마스터하고 나면, 다양한 stringr 함수들에 어떻게 적용을 해야하는지 알 수 있다.

### 14.3.1 Basic matches
가장 간단한 패턴 매칭은 exact strings다.
```{r eval=FALSE}
x <- c("apple", "banana", "pear")
str_view(x, "an")
```
![그림](C:\Users\Phil2\Desktop\20191126_062106.png)































